#include "vinac.h"

// Insere um ou mais arquivos no arquivador .vc
// Se o arquivo já existir, é atualizado mantendo sua ordem mas com novo UID
void vinac_insert(int argc, char *argv[], uint32_t compress)
{
    if (argc < 4)
    {
        fprintf(stderr, "Uso: vinac -i[c] arquivo.vc arquivo1 [arquivo2 ...]\n");
        return;
    }

    const char *arquivoVC = argv[2];
    FILE *vc = NULL;
    IndiceArquivador indice;
    inicializarIndice(&indice);

    // Verifica se o arquivo .vc já existe
    if (access(arquivoVC, F_OK) == 0)
    {
        vc = fopen(arquivoVC, "r+b");
        if (!vc)
        {
            fprintf(stderr, "Erro ao abrir o arquivo %s\n", arquivoVC);
            destruirIndice(&indice);
            return;
        }
        if (carregarIndice(vc, &indice) < 0)
        {
            fprintf(stderr, "Erro ao carregar o índice do arquivador.\n");
            fclose(vc);
            destruirIndice(&indice);
            return;
        }
    }
    else
    {
        vc = fopen(arquivoVC, "w+b");
        if (!vc)
        {
            fprintf(stderr, "Erro ao criar o arquivo %s\n", arquivoVC);
            destruirIndice(&indice);
            return;
        }
        // Inicializa o arquivo com um índice vazio
        uint32_t numMembros = 0;
        if (fwrite(&numMembros, sizeof(uint32_t), 1, vc) != 1)
        {
            fprintf(stderr, "Erro ao inicializar o arquivo %s\n", arquivoVC);
            fclose(vc);
            destruirIndice(&indice);
            return;
        }
    }

    // Calcula a quantidade total de arquivos após a inserção
    uint32_t quantidade_total = indice.lista.quantidade + (argc - 3);
    // Calcula o novo tamanho do header (header + metadados de todos os arquivos)
    uint64_t novoHeader = sizeof(uint32_t) + (quantidade_total * sizeof(ArquivoMembro));
    // Realoca dados dos arquivos antigos se necessário
    uint64_t offsetDados = novoHeader;
    No *atual = indice.lista.primeiro;
    while (atual)
    {
        if (atual->arquivo.offset != offsetDados)
        {
            moverDados(vc, atual->arquivo.offset, offsetDados, atual->arquivo.emDisco);
            atual->arquivo.offset = offsetDados;
        }
        offsetDados += atual->arquivo.emDisco;
        atual = atual->proximo;
    }

    // Processa cada arquivo novo
    for (int i = 3; i < argc; i++)
    {
        // Inserção plana
        ArquivoMembro novoMembro;
        strncpy(novoMembro.nome, argv[i], sizeof(novoMembro.nome) - 1);
        novoMembro.nome[sizeof(novoMembro.nome) - 1] = '\0';
        novoMembro.uid = indice.ultimoUID + 1;
        indice.ultimoUID = novoMembro.uid;
        novoMembro.modificacao = time(NULL);
        novoMembro.ordem = indice.lista.quantidade;
        novoMembro.offset = offsetDados;

        uint32_t tamanhoFinal = 0;
        if (inserirArquivo(argv[i], vc, &offsetDados, &tamanhoFinal, compress) != 0)
        {
            fprintf(stderr, "Erro ao inserir os dados do arquivo %s no .vc\n", argv[i]);
            continue;
        }
        novoMembro.tamanho = tamanhoFinal;
        novoMembro.emDisco = tamanhoFinal;

        adicionarAoIndice(&indice, novoMembro);
        printf("Arquivo '%s' adicionado ao índice e ao .vc com sucesso.\n", argv[i]);
    }

    // Salva apenas o índice atualizado
    rewind(vc);
    if (salvarIndice(vc, &indice) < 0)
    {
        fprintf(stderr, "Erro ao salvar o índice no arquivador.\n");
    }

    destruirIndice(&indice);
    fclose(vc);
}